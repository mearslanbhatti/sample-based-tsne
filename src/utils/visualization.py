from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt

def plot_grid(embeddings_to_be_plotted, row_var="perplexity", col_var="num_samples", 
              figsize=None, axis=False, suptitle=None, supxlabel=None, supylabel=None, in_title=None):
    """ Given embeddings generated by altering two variables. Plots them in a grid with 
    `row_var` and `col_var` corresponding to each changing variable.

    Parameters
    ----------
    embeddings_to_be_plotted : list(Dict())
        A list of dictionaries, each containing the number of samples "num_samples", 
        the used "perplexity", the used initialial embedding "init", the obtained "embedding", 
        and the corresponding "labels" as well as times for computation of the affinities 
        "t_affinities", the optimization "t_optimization", and the total time spent "t_total".
    row_var : String
        Which of the fields from the embeddings dictionary to be plotted in the rows.
    col_var : String
        Which of the fields from the embeddings dictionary to be plotted in the columns
    figsize : (int, int)
        Tuple with the figure size (width, height)
    axis : Boolean
        Whether to plot axes in the individual plots.
    suptitle : String
        A title for the set of plots
    supxlabel : String
        A title for the columns of the set of plots
    supylabel : String
        A title for the rows of the set of plots
    in_title : list(String)
        A list of fields from the embeddings dictionary to be included in the title of the individual plots.
    Returns
    -------
    figure, axes : Matplotlib Figure and Axes
        A figure with the set of plots and the axes containing the individual plots.
    """
    rows = sorted(set([e[row_var] for e in embeddings_to_be_plotted]))
    cols = sorted(set([e[col_var] for e in embeddings_to_be_plotted]))

    nrows = len(rows)
    ncols = len(cols)

    if in_title is None:
        in_title = [row_var, col_var]
    if figsize is None:
        figsize = (ncols*3, nrows*4)

    figure, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize, layout="tight")
    if type(axes) != np.ndarray:
        axes = np.array(axes)
    axes = axes.reshape(nrows, ncols)

    for ri, rl in enumerate(rows):
        for ci, cl in enumerate(cols):
            emb_data = [emb for emb in embeddings_to_be_plotted if emb[row_var] == rl and emb[col_var] == cl][0]
            axes[ri, ci].scatter(emb_data["embedding"][:, 0], emb_data["embedding"][:, 1], s=1, c=emb_data["labels"], cmap="tab10")
            if not axis:
                axes[ri, ci].set_axis_off()
            
            title = "\n".join([f"{l}: {emb_data[l]:.4f}" if type(emb_data[l]) is not int else f"{l}: {emb_data[l]}" for l in in_title])
            axes[ri, ci].set_title(title)

    if suptitle is not None:
        figure.suptitle(suptitle)

    if supxlabel is not None:
        figure.supxlabel(supxlabel)

    if supylabel is not None:
        figure.supylabel(supylabel)

    return figure, axes


def save_fig(figure, fname, overwrite=False, dpi=300):
    if Path(fname).exists() and not overwrite:
        print("File already exists. Remove or rename {} before continuing.".format(fname))
    else:
        figure.savefig(fname, dpi=dpi)